#include "cxx_generator.hxx"
#include "../data_types.hxx"
#include "../string_util/case_conv.hxx"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <optional>
#include <set>
#include <sstream>

const std::filesystem::path HEADER_FILE_EXT(".np.hxx");
const std::filesystem::path CODE_FILE_EXT(".np.cxx");

std::map<std::string, std::string> NP_TYPE_TO_CXX_TYPE = {
	{TYPE_STRING, "std::string"},
	{TYPE_BOOL, "bool"},
	{TYPE_DOUBLE, "double"},
	{TYPE_INT8, "int8_t"},
	{TYPE_INT32, "int32_t"}};

std::optional<std::string>
get_cxx_type_name_by_np_type_name(const std::string &np_type_name) {
	const auto pos = NP_TYPE_TO_CXX_TYPE.find(np_type_name);
	if (pos == NP_TYPE_TO_CXX_TYPE.end()) {
		return std::nullopt;
	}
	return pos->second;
}

CxxGenerator::CxxGenerator() = default;

void CxxGenerator::generate_for_schema(const MessageSchema &schema) {
	const std::string header_file_name = generate_header_file(schema);
	generate_code_file(schema, header_file_name);
}

std::string CxxGenerator::generate_header_file(const MessageSchema &schema) {
	std::ofstream output_hxx_file;
	std::filesystem::path output_hxx_path(schema.schema_path);
	output_hxx_path.replace_extension(HEADER_FILE_EXT);

	std::stringstream ss;
	// TODO: this doesn't work with namespaced message names
	ss << "__" << schema.message_name << "_NP_H__";

	std::string include_guard_name = ss.str();

	output_hxx_file.open(output_hxx_path);

	std::set<std::string> required_types;
	for (const MessageField &field : schema.fields) {
		required_types.insert(field.type_name);
	}

	// clang-format off
	output_hxx_file
	<< "// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND." << std::endl
	<< std::endl
	<< "#ifndef " << include_guard_name << std::endl
	<< "#define " << include_guard_name << std::endl
	<< std::endl
	<< "#include <nanopack/nanobuf.hxx>" << std::endl;
	// clang-format on

	if (required_types.contains(TYPE_STRING)) {
		output_hxx_file << "#include <string>" << std::endl;
	}
	// TODO: implement support for including custom message types

	// clang-format off
	output_hxx_file
	<< std::endl
	<< "struct " << schema.message_name << " {" << std::endl
	<< "private:" << std::endl
	<< "  static const int FIELD_COUNT = " << schema.fields.size() << ";" << std::endl
	<< std::endl
	<< "public:" << std::endl
	<< "  static const int32_t TYPE_ID = " << schema.type_id << ";" << std::endl
	<< std::endl;
	// clang-format on

	for (const MessageField &field : schema.fields) {
		const std::optional<std::string> cxx_type_name =
			get_cxx_type_name_by_np_type_name(field.type_name);
		if (cxx_type_name.has_value()) {
			output_hxx_file << "  " << cxx_type_name.value() << " "
							<< camel_to_snake(field.field_name) << ";"
							<< std::endl;
		} else {
			// TODO: implement support for custom message types
		}
	}

	// clang-format off
	output_hxx_file
	<< "  " << schema.message_name << "();" << std::endl
	<< std::endl
	<< "  explicit " << schema.message_name << "(std::vector<uint8_t> &data);" << std::endl
	<< std::endl
	<< "  NanoBuf data();" << std::endl
	<< "};" << std::endl
	<< std::endl
	<< "#endif" << std::endl;
	// clang-format on

	output_hxx_file.close();

	return output_hxx_path.filename();
}

void CxxGenerator::generate_code_file(const MessageSchema &schema,
									  const std::string &header_file_name) {
	std::ofstream output_file;
	std::filesystem::path output_path(schema.schema_path);
	output_path.replace_extension(CODE_FILE_EXT);

	output_file.open(output_path);

	// clang-format off
	output_file
	<< "#include \"" << header_file_name << "\"" << std::endl
	<< std::endl
	<< schema.message_name << "::" << schema.message_name << "() {}" << std::endl
	<< std::endl
	<< schema.message_name << "::" << schema.message_name << "(std::vector<uint8_t> &data) {" << std::endl
	<< "  NanoBuf buf(data);"
	<< "  int ptr = " << 4 * (schema.fields.size() + 1) << ";" << std::endl
	<< std::endl
	<< "  const int32_t type_id = buf.read_type_id();" << std::endl
	<< "  if (type_id != " << schema.message_name << "::TYPE_ID) {" << std::endl
	<< "    throw \"incompatible type\";" << std::endl
	<< "  }" << std::endl
	<< std::endl;
	// clang-format on

	for (const MessageField &field : schema.fields) {
		const std::string field_name_snake_case =
			camel_to_snake(field.field_name);

		if (field.type_name == TYPE_STRING) {
			// clang-format off
			output_file
			<< "  const int32_t " << field_name_snake_case << "_size = buf.read_field_size(" << field.field_number << ");" << std::endl
			<< "  std::string " << field_name_snake_case << " = buf.read_string(ptr, " << field_name_snake_case << "_size);" << std::endl
			<< "  ptr += " << field_name_snake_case << "_size;" << std::endl
			<< "  this->" << field_name_snake_case << " = " << field_name_snake_case << ";" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_BOOL) {
			// clang-format off
			output_file
			<< "  const bool " << field_name_snake_case << " = buf.read_bool(ptr++);" << std::endl
			<< "  this->" << field_name_snake_case << " = " << field_name_snake_case << ";" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_INT8) {
			// clang-format off
			output_file
			<< "  const int8_t " << field_name_snake_case << " = buf.read_int8(ptr);" << std::endl
			<< "  ptr += sizeof(int8_t);" << std::endl
			<< "  this->" << field_name_snake_case << " = " << field_name_snake_case << ";" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_INT32) {
			// clang-format off
			output_file
			<< "  const int32_t " << field_name_snake_case << " = buf.read_int32(ptr);" << std::endl
			<< "  ptr += sizeof(int32_t);" << std::endl
			<< "  this->" << field_name_snake_case << " = " << field_name_snake_case << ";" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_DOUBLE) {
			// clang-format off
			output_file
			<< "  const double " << field_name_snake_case << " = buf.read_double(ptr);" << std::endl
			<< "  ptr += sizeof(double);" << std::endl
			<< "  this->" << field_name_snake_case << " = " << field_name_snake_case << ";" << std::endl
			<< std::endl;
			// clang-format on
		} else {
			// TODO: implement array
		}
	}

	output_file << "}" << std::endl << std::endl;

	// clang-format off
	output_file
	<< "NanoBuf " << schema.message_name << "::data() {" << std::endl
	<< "  NanoBuf buf(sizeof(int32_t) * " << schema.fields.size() + 1 << ");" << std::endl
	<< std::endl
	<< "  buf.write_type_id(" << schema.message_name << "::TYPE_ID);" << std::endl
	<< std::endl;
	// clang-format on

	for (const MessageField &field : schema.fields) {
		const std::string field_name_snake_case =
			camel_to_snake(field.field_name);

		if (field.type_name == TYPE_STRING) {
			// clang-format off
			output_file
			<< "  buf.write_field_size(" << field.field_number << ", " << field_name_snake_case << ".size());" << std::endl
			<< "  buf.append_string(" << field_name_snake_case << ");" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_BOOL) {
			// clang-format off
			output_file
			<< "  buf.write_field_size(" << field.field_number << ", 1);" << std::endl
			<< "  buf.append_bool(" << field_name_snake_case << ");" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_INT8) {
			// clang-format off
			output_file
			<< "  buf.write_field_size(" << field.field_number << ", sizeof(int8_t));" << std::endl
			<< "  buf.append_int8(" << field_name_snake_case << ");" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_INT32) {
			// clang-format off
			output_file
			<< "  buf.write_field_size(" << field.field_number << ", sizeof(int32_t));" << std::endl
			<< "  buf.append_int32(" << field_name_snake_case << ");" << std::endl
			<< std::endl;
			// clang-format on
		} else if (field.type_name == TYPE_DOUBLE) {
			// clang-format off
			output_file
			<< "  buf.write_field_size(" << field.field_number << ", sizeof(double));" << std::endl
			<< "  buf.append_double(" << field_name_snake_case << ");" << std::endl
			<< std::endl;
			// clang-format on
		} else {
			// TODO: implement array
		}
	}

	output_file << "  return buf;" << std::endl
				<< "}" << std::endl
				<< std::endl;

	output_file.close();
}
