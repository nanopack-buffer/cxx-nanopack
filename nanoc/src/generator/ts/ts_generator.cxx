#include "ts_generator.hxx"

#include "../../data_type/np_array.hxx"
#include "../../data_type/np_bool.hxx"
#include "../../data_type/np_int32.hxx"
#include "../../data_type/np_int8.hxx"
#include "../../data_type/np_map.hxx"
#include "../../data_type/np_optional.hxx"
#include "../../data_type/np_string.hxx"
#include "../../string_util/case_conv.hxx"
#include "ts_array_generator.hxx"
#include "ts_bool_generator.hxx"
#include "ts_int32_generator.hxx"
#include "ts_int8_generator.hxx"
#include "ts_map_generator.hxx"
#include "ts_message_generator.hxx"
#include "ts_optional_generator.hxx"
#include "ts_string_generator.hxx"

#include <fstream>

const std::filesystem::path CODE_FILE_EXT(".np.ts");

TsGenerator::TsGenerator()
	: user_defined_message_type_generator(
		  std::make_shared<TsMessageGenerator>()),
	  data_type_generator_registry(
		  std::make_shared<DataTypeCodeGeneratorRegistry>()) {
	data_type_generator_registry->add_generator_for_type(
		NanoPack::Bool::IDENTIFIER, std::make_shared<TsBoolGenerator>());
	data_type_generator_registry->add_generator_for_type(
		NanoPack::Int8::IDENTIFIER, std::make_shared<TsInt8Generator>());
	data_type_generator_registry->add_generator_for_type(
		NanoPack::Int32::IDENTIFIER, std::make_shared<TsInt32Generator>());
	data_type_generator_registry->add_generator_for_type(
		NanoPack::String::IDENTIFIER, std::make_shared<TsStringGenerator>());
	data_type_generator_registry->add_generator_for_type(
		NanoPack::Array::IDENTIFIER,
		std::make_shared<TsArrayGenerator>(data_type_generator_registry));
	data_type_generator_registry->add_generator_for_type(
		NanoPack::Map::IDENTIFIER,
		std::make_shared<TsMapGenerator>(data_type_generator_registry));
	data_type_generator_registry->add_generator_for_type(
		NanoPack::Optional::IDENTIFIER,
		std::make_shared<TsOptionalGenerator>(data_type_generator_registry));
}

void TsGenerator::generate_for_schema(const MessageSchema &schema) {
	std::ofstream output_file_stream;
	CodeOutput code_output(output_file_stream, schema);
	std::filesystem::path output_path(schema.schema_path);
	output_path.replace_filename(snake_to_kebab(output_path.filename()))
		.replace_extension(CODE_FILE_EXT);

	output_file_stream.open(output_path);

	// clang-format off
	code_output.stream()
	<< "// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND." << std::endl
	<< std::endl
	<< "import { NanoBufReader, NanoBufWriter } from \"nanopack\"" << std::endl
	<< std::endl
	<< "class " << schema.message_name << "{" << std::endl
	<< "    public static TYPE_ID = " << schema.type_id << ";" << std::endl
	<< std::endl
	<< "    constructor(";
	// clang-format on

	for (const MessageField &field : schema.declared_fields) {
		const std::shared_ptr<DataTypeCodeGenerator> generator =
			find_generator_for_field(field);
		if (generator == nullptr)
			continue;

		code_output.stream() << "public ";
		generator->generate_constructor_parameter(code_output, field);
		code_output.stream() << ", ";
	}

	// clang-format off
	code_output.stream()
	<< ") {}" << std::endl
	<< std::endl
	<< "public static fromBytes(bytes: Uint8Array): { bytesRead: number, result: " << schema.message_name << " } | null {" << std::endl
	<< "    const reader = new NanoBufReader(bytes);" << std::endl
	<< "    if (reader.readTypeId() !== " << schema.message_name << ".TYPE_ID) {" << std::endl
	<< "        return null;" << std::endl
	<< "    }"
	<< std::endl
	<< "    let ptr = " << (schema.declared_fields.size() + 1) * 4 << ";" << std::endl
	<< std::endl;
	// clang-format on

	for (const MessageField &field : schema.declared_fields) {
		const std::shared_ptr<DataTypeCodeGenerator> generator =
			find_generator_for_field(field);
		if (generator == nullptr)
			continue;

		generator->generate_read_code(code_output, field);
		code_output.stream() << std::endl;
	}

	// clang-format off
	code_output.stream()
	<< "return { bytesRead: ptr, result: new " << schema.message_name << "(";
	// clang-format on

	for (const MessageField &field : schema.declared_fields) {
		code_output.stream() << snake_to_camel(field.field_name) << ", ";
	}

	// clang-format off
	code_output.stream()
	<< ") };" << std::endl
	<< "}" << std::endl
	<< std::endl
	<< "public bytes(): Uint8Array {" << std::endl
	<< "    const writer = new NanoBufWriter(" << (schema.declared_fields.size() + 1) * 4 << ");" << std::endl
	<< "    writer.writeTypeId(" << schema.message_name << ".TYPE_ID);" << std::endl
	<< std::endl;
	// clang-format on

	for (const MessageField &field : schema.declared_fields) {
		const std::shared_ptr<DataTypeCodeGenerator> generator =
			find_generator_for_field(field);
		if (generator == nullptr)
			continue;

		generator->generate_write_code(code_output, field);
		code_output.stream() << std::endl;
	}

	// clang-format off
	code_output.stream()
	<< "    return writer.bytes;" << std::endl
	<< "}" << std::endl
	<< "}" << std::endl
	<< std::endl
	<< "export { " << schema.message_name << " };" << std::endl;
	// clang-format on

	output_file_stream.close();

	const std::string format_cmd =
		"npx prettier " + output_path.string() + " --write";
	system(format_cmd.c_str());
}

void TsGenerator::generate_message_factory(
	const std::vector<MessageSchema> &all_schemas,
	const std::filesystem::path &output_path) {}

std::shared_ptr<DataTypeCodeGenerator>
TsGenerator::find_generator_for_field(const MessageField &field) const {
	auto generator =
		data_type_generator_registry->find_generator_for_type(field.type.get());
	if (generator == nullptr)
		return user_defined_message_type_generator;
	return generator;
}
